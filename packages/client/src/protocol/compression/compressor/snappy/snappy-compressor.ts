import { type Compressor } from '../compressor';
import { compress, uncompress } from 'snappy';
import { IllegalArgumentError } from '../../../exceptions';

/**
 * The original Snappy format definition did not define a file format. It later added a "framing" format to define a
 * file format, but by this point major software was already using an industry standard instead -- represented in this
 * library by the SnappyOutputStream and SnappyInputStream methods.
 *
 * SnappyOutputStream and SnappyInputStream use [magic header:16 bytes]([block size:int32][compressed data:byte array])*
 * format. You can read the result of Snappy.compress with SnappyInputStream, but you cannot read the compressed data
 * generated by SnappyOutputStream with Snappy.uncompress.
 *
 * SnappyOutputStreamData => magic_header version compatible_version [compressed_data]
 *   magic_header => BYTES
 *   version => INT32
 *   compatible_version => INT32
 *   compressed_data => length data
 *    length => INT32
 *    data => BYTES
 *
 * @see https://github.com/xerial/snappy-java#compatibility-notes
 */
export class SnappyCompressor implements Compressor {
  private static readonly MAGIC_HEADER = Buffer.from([0x82, 0x53, 0x4e, 0x41, 0x50, 0x50, 0x59, 0x00]);
  private static readonly VERSION_OFFSET = SnappyCompressor.MAGIC_HEADER.length;
  private static readonly FIRST_SLICE_OFFSET = SnappyCompressor.MAGIC_HEADER.length + 8;
  private static readonly MINIMUM_COMPATIBLE_VERSION = 1;

  /**
   * This method returns output compatible with the org.xerial.snappy.Snappy#compress(byte[]) from the snappy-java
   * library. Because the org.xerial.snappy.SnappyInputStream can handle this output format, the simpler approach is
   * being used.
   *
   * @see https://github.com/xerial/snappy-java#compatibility-notes
   * @param buffer with bytes to compress
   */
  public async compress(buffer: Buffer): Promise<Buffer> {
    return compress(buffer);
  }

  /**
   * Decompresses the payload compressed either with the support of the org.xerial.snappy.SnappyOutputStream or by
   * calling the org.xerial.snappy.Snappy#compress(byte[]) from the snappy-java library. This follows the behavior
   * of the org.xerial.snappy.SnappyInputStream. If the header added by the org.xerial.snappy.SnappyOutputStream is
   * detected, the payload will be decompressed slice after slice. Otherwise, the decompression will be performed
   * directly on the whole payload.
   *
   * @see https://github.com/xerial/snappy-java#compatibility-notes
   * @param buffer with compressed bytes
   */
  public async decompress(buffer: Buffer): Promise<Buffer> {
    if (buffer.length < 1) {
      // Snappy produces at least 1-byte result. So the empty input is not a valid input
      throw new IllegalArgumentError('Cannot decompress empty buffer');
    }

    if (!this.isFromSnappyOutputStream(buffer)) {
      return uncompress(buffer) as Promise<Buffer>;
    }

    const version = buffer.readInt32BE(SnappyCompressor.VERSION_OFFSET);
    if (version < SnappyCompressor.MINIMUM_COMPATIBLE_VERSION) {
      throw new IllegalArgumentError(
        `Compressed with an incompatible codec version ${version}. At least version ${SnappyCompressor.MINIMUM_COMPATIBLE_VERSION} is required`
      );
    }

    let currentOffset = SnappyCompressor.FIRST_SLICE_OFFSET;
    const dataSlices: Buffer[] = [];
    while (currentOffset < buffer.length) {
      const sliceLength = buffer.readInt32BE(currentOffset);
      currentOffset += 4;

      const compressedSlice = buffer.subarray(currentOffset, currentOffset + sliceLength);
      currentOffset += sliceLength;

      const uncompressedSlice = (await uncompress(compressedSlice)) as Buffer;
      dataSlices.push(uncompressedSlice);
    }

    return Buffer.concat(dataSlices);
  }

  private isFromSnappyOutputStream(buffer: Buffer): boolean {
    return buffer.subarray(0, SnappyCompressor.MAGIC_HEADER.length).equals(SnappyCompressor.MAGIC_HEADER);
  }
}
